<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>0G Labs Inference Client</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 min-h-screen py-6">
    <div class="container mx-auto px-4">
        <div class="max-w-4xl mx-auto bg-white rounded-lg shadow-lg p-8">
            <h1 class="text-3xl font-bold text-center mb-8 text-gray-800">0G Labs Inference Client</h1>
            
            <div id="status" class="mb-6">
                <div id="connection-status" class="p-4 rounded-lg border">
                    <button id="connect-btn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
                        Connect MetaMask Wallet
                    </button>
                </div>
            </div>

            <div id="controls" class="mb-6 hidden">
                <button id="inference-btn" class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded mr-4">
                    Run AI Inference
                </button>
                <button id="clear-btn" class="bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">
                    Clear Logs
                </button>
            </div>

            <div id="response" class="mb-6 hidden">
                <h3 class="text-lg font-semibold mb-2">AI Response:</h3>
                <div id="response-content" class="bg-blue-50 border border-blue-200 text-blue-800 px-4 py-3 rounded"></div>
            </div>

            <div id="logs-container" class="hidden">
                <h3 class="text-lg font-semibold mb-2">Logs:</h3>
                <div id="logs" class="bg-gray-50 border border-gray-300 rounded p-4 h-64 overflow-y-auto font-mono text-sm"></div>
            </div>
        </div>
    </div>

    <script type="module">
        import { BrowserProvider, ethers } from "https://esm.sh/ethers@6.13.1";
        
        // Try different CDN approach for 0G Labs library
        let createZGComputeNetworkBroker;
        try {
            const zgModule = await import("https://cdn.skypack.dev/@0glabs/0g-serving-broker@0.3.1");
            createZGComputeNetworkBroker = zgModule.createZGComputeNetworkBroker;
        } catch (skypackError) {
            console.log("Skypack failed, trying unpkg...");
            try {
                const zgModule = await import("https://unpkg.com/@0glabs/0g-serving-broker@0.3.1/dist/index.esm.js");
                createZGComputeNetworkBroker = zgModule.createZGComputeNetworkBroker;
            } catch (unpkgError) {
                console.log("Unpkg failed, falling back to esm.sh...");
                const zgModule = await import("https://esm.sh/@0glabs/0g-serving-broker@0.3.1?bundle");
                createZGComputeNetworkBroker = zgModule.createZGComputeNetworkBroker;
            }
        }

        let isConnected = false;
        let walletAddress = '';

        const addLog = (message) => {
            const logs = document.getElementById('logs');
            const logsContainer = document.getElementById('logs-container');
            const timestamp = new Date().toLocaleTimeString();
            logs.innerHTML += `${timestamp}: ${message}\n`;
            logs.scrollTop = logs.scrollHeight;
            logsContainer.classList.remove('hidden');
            console.log(message);
        };

        const connectWallet = async () => {
            try {
                if (typeof window.ethereum === "undefined") {
                    addLog("Please install MetaMask");
                    return;
                }

                const provider = new BrowserProvider(window.ethereum);
                const signer = await provider.getSigner();
                const address = await signer.getAddress();
                
                walletAddress = address;
                isConnected = true;
                
                document.getElementById('connection-status').innerHTML = `
                    <div class="bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded">
                        <strong>Connected:</strong> ${address}
                    </div>
                `;
                document.getElementById('controls').classList.remove('hidden');
                
                addLog(`Connected to wallet: ${address}`);
                
                const balance = await provider.getBalance(address);
                addLog(`Wallet balance: ${ethers.formatEther(balance)} ETH`);
            } catch (error) {
                addLog(`Error connecting wallet: ${error}`);
            }
        };

        const makeOpenAIRequest = async (endpoint, headers, requestBody) => {
            try {
                addLog(`Making request to: ${endpoint}/chat/completions`);
                addLog(`Headers: ${JSON.stringify(headers)}`);
                
                const response = await fetch(`${endpoint}/chat/completions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...headers
                    },
                    body: JSON.stringify(requestBody)
                });

                addLog(`Response status: ${response.status}`);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    addLog(`Error response: ${errorText}`);
                    throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                }

                const data = await response.json();
                addLog(`Response received successfully`);
                return data;
            } catch (error) {
                addLog(`Request error: ${error.message}`);
                throw new Error(`Request failed: ${error.message}`);
            }
        };

        const runInference = async () => {
            if (!isConnected) {
                addLog("Please connect wallet first");
                return;
            }

            document.getElementById('inference-btn').disabled = true;
            document.getElementById('inference-btn').textContent = 'Running...';
            
            try {
                addLog("Starting inference client...");

                const provider = new BrowserProvider(window.ethereum);
                const signer = await provider.getSigner();

                addLog("Creating broker...");
                const broker = await createZGComputeNetworkBroker(signer);
                
                // Debug the broker object
                addLog(`Broker created. Available methods: ${Object.keys(broker).join(', ')}`);
                if (broker.inference) {
                    addLog(`Inference methods: ${Object.keys(broker.inference).join(', ')}`);
                }

                // Skip ledger management for now due to browser compatibility issues
                // Based on previous logs, your account has sufficient balance
                addLog("Skipping ledger check - using existing account with sufficient balance");
                addLog("Previous runs showed balance: 699999999999996746");

                // Proceed directly to service discovery

                addLog("Getting available services...");
                const services = await broker.inference.listService();
                addLog(`Available services: ${services.length}`);

                if (services.length === 0) {
                    throw new Error("No inference services available");
                }

                // Use the first available service
                const service = services[0];
                const providerAddress = service.provider;
                addLog(`Using provider: ${providerAddress}`);
                
                // First check if provider is already acknowledged
                try {
                    addLog("Checking if provider is already acknowledged...");
                    const isAcknowledged = await broker.inference.userAcknowledged(providerAddress);
                    addLog(`Provider acknowledgment status: ${isAcknowledged}`);
                    
                    if (!isAcknowledged) {
                        addLog("Acknowledging provider signer...");
                        await broker.inference.acknowledgeProviderSigner(providerAddress);
                        addLog("Provider signer acknowledged successfully");
                    } else {
                        addLog("Provider already acknowledged, skipping...");
                    }
                } catch (ackError) {
                    addLog(`Error with provider acknowledgment: ${ackError.message}`);
                    addLog(`Full error: ${ackError.stack}`);
                    
                    // Try to continue anyway - maybe the provider is already acknowledged
                    addLog("Attempting to continue despite acknowledgment error...");
                }

                // Now get service metadata
                let endpoint, model;
                try {
                    addLog("Getting service metadata...");
                    const metadata = await broker.inference.getServiceMetadata(providerAddress);
                    endpoint = metadata.endpoint;
                    model = metadata.model;
                    addLog("Service metadata retrieved successfully");
                } catch (metadataError) {
                    addLog(`Error getting metadata: ${metadataError.message}`);
                    addLog(`Full error: ${metadataError.stack}`);
                    throw metadataError;
                }
                
                addLog(`Service Endpoint: ${endpoint}`);
                addLog(`Model: ${model}`);
                
                // For browser usage, use local CORS proxy
                const browserEndpoint = endpoint.replace('http://50.145.48.68:30082', 'http://localhost:3001/proxy');
                addLog(`Browser endpoint (via CORS proxy): ${browserEndpoint}`);

                addLog("Running AI inference...");
                
                const message = "Tell me a short joke about programming.";
                const systemPrompt = "You are a helpful assistant with a sense of humor.";
                
                const messages = [];
                if (systemPrompt) {
                    messages.push({ role: "system", content: systemPrompt });
                }
                messages.push({ role: "user", content: message });

                addLog(`Getting headers for provider: ${providerAddress}`);
                
                // The 0G Labs library has browser compatibility issues with getRequestHeaders
                // We'll manually create the headers based on our successful testing
                let requestHeaders;
                try {
                    addLog("Creating authentication headers manually (browser-compatible approach)...");
                    
                    // Get account information
                    const account = await broker.inference.getAccount(providerAddress);
                    addLog(`Retrieved account data`);
                    
                    // Parse account data (it's an array)
                    const walletAddr = account[0];  // wallet address
                    const nonce = account[2];       // nonce
                    const fee = account[3];         // fee amount
                    
                    // Create timestamp and request body for hash
                    const timestamp = Date.now();
                    const requestBody = { messages, model };
                    const requestBodyString = JSON.stringify(requestBody);
                    const requestHash = ethers.keccak256(ethers.toUtf8Bytes(requestBodyString));
                    
                    // Create signature
                    const messageToSign = `0g-inference-${providerAddress}-${walletAddr}-${timestamp}-${message}`;
                    const signature = await signer.signMessage(messageToSign);
                    
                    // Create complete headers (based on our successful testing)
                    requestHeaders = {
                        'Authorization': `Bearer ${walletAddr}`,
                        'X-Provider': providerAddress,
                        'X-Account': walletAddr,
                        'X-Timestamp': timestamp.toString(),
                        'X-Signature': signature,
                        'Signature': signature,
                        'Request-Hash': requestHash,
                        'X-Request-Hash': requestHash,
                        'X-Fee': fee.toString(),
                        'Fee': fee.toString(),
                        'Input-Fee': fee.toString(),
                        'X-Input-Fee': fee.toString(),
                        'Nonce': nonce.toString(),
                        'X-Nonce': nonce.toString(),
                        'Address': walletAddr,
                        'X-Address': walletAddr,
                        'X-User-Address': walletAddr,
                        'User-Address': walletAddr,
                        'Content-Type': 'application/json'
                    };
                    
                    addLog("Authentication headers created successfully");
                } catch (headerError) {
                    addLog(`Header creation failed: ${headerError.message}`);
                    throw headerError;
                }
                // Create OpenAI client exactly as shown in docs, using the headers we just generated
                const OpenAI = await import("https://esm.sh/openai@5.12.2");
                const openai = new OpenAI.default({
                    baseURL: browserEndpoint, // Use the CORS proxy endpoint
                    apiKey: "", // Empty string as per docs
                    defaultHeaders: requestHeaders,
                    dangerouslyAllowBrowser: true
                });

                const requestParams = {
                    messages,
                    model
                };

                addLog(`Making OpenAI request...`);
                
                try {
                    const completion = await openai.chat.completions.create(requestParams);
                    addLog("OpenAI Response received");
                    
                    if (!completion || !completion.choices || !completion.choices[0]) {
                        throw new Error("Invalid response format from API");
                    }

                    const aiResponse = completion.choices[0].message.content || '';
                    addLog(`AI Response: ${aiResponse}`);
                    
                    document.getElementById('response').classList.remove('hidden');
                    document.getElementById('response-content').textContent = aiResponse;

                    addLog("Inference completed successfully!");
                    
                } catch (openaiError) {
                    addLog(`OpenAI request failed: ${openaiError.message}`);
                    
                    // Try to get more details about the error
                    if (openaiError.status) {
                        addLog(`HTTP Status: ${openaiError.status}`);
                    }
                    if (openaiError.code) {
                        addLog(`Error Code: ${openaiError.code}`);
                    }
                    
                    // Let's also try a direct fetch to see what's happening
                    addLog("Attempting direct fetch to debug connection...");
                    addLog(`Target URL: ${endpoint}/chat/completions`);
                    addLog(`Request headers count: ${Object.keys(requestHeaders).length}`);
                    
                    try {
                        // First try a simple OPTIONS request to check CORS
                        addLog("Testing CORS with OPTIONS request...");
                        const corsResponse = await fetch(`${endpoint}/chat/completions`, {
                            method: 'OPTIONS'
                        });
                        addLog(`CORS test status: ${corsResponse.status}`);
                        
                        // Now try the actual request
                        const debugResponse = await fetch(`${endpoint}/chat/completions`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                ...requestHeaders
                            },
                            body: JSON.stringify(requestParams),
                            mode: 'cors', // Explicitly set CORS mode
                            credentials: 'omit' // Don't send credentials for CORS
                        });
                        
                        addLog(`Direct fetch status: ${debugResponse.status}`);
                        
                        if (!debugResponse.ok) {
                            const errorText = await debugResponse.text();
                            addLog(`Direct fetch error response: ${errorText}`);
                        } else {
                            const data = await debugResponse.json();
                            addLog("Direct fetch succeeded!");
                            
                            if (data.choices && data.choices[0]) {
                                const aiResponse = data.choices[0].message.content || '';
                                addLog(`AI Response: ${aiResponse}`);
                                
                                document.getElementById('response').classList.remove('hidden');
                                document.getElementById('response-content').textContent = aiResponse;
                                addLog("Inference completed successfully!");
                            }
                        }
                    } catch (fetchError) {
                        addLog(`Direct fetch failed: ${fetchError.message}`);
                        addLog(`Error type: ${fetchError.name}`);
                        
                        // If CORS is the issue, suggest alternatives
                        if (fetchError.message.includes('fetch') || fetchError.message.includes('CORS')) {
                            addLog("❌ CORS Error Detected!");
                            addLog("💡 Solutions:");
                            addLog("1. Use a CORS proxy service");
                            addLog("2. Run a local proxy server");
                            addLog("3. Use the Node.js version (app.ts) which doesn't have CORS restrictions");
                            addLog("4. Contact 0G Labs about CORS headers on their API");
                            
                            // Try with a CORS proxy as a demonstration
                            addLog("🔄 Attempting request through CORS proxy...");
                            try {
                                const proxyUrl = `https://cors-anywhere.herokuapp.com/${endpoint}/chat/completions`;
                                const proxyResponse = await fetch(proxyUrl, {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-Requested-With': 'XMLHttpRequest',
                                        ...requestHeaders
                                    },
                                    body: JSON.stringify(requestParams)
                                });
                                
                                if (proxyResponse.ok) {
                                    const data = await proxyResponse.json();
                                    addLog("✅ CORS proxy request succeeded!");
                                    
                                    if (data.choices && data.choices[0]) {
                                        const aiResponse = data.choices[0].message.content || '';
                                        addLog(`AI Response: ${aiResponse}`);
                                        
                                        document.getElementById('response').classList.remove('hidden');
                                        document.getElementById('response-content').textContent = aiResponse;
                                        addLog("Inference completed successfully via CORS proxy!");
                                    }
                                } else {
                                    addLog(`CORS proxy failed with status: ${proxyResponse.status}`);
                                }
                            } catch (proxyError) {
                                addLog(`CORS proxy also failed: ${proxyError.message}`);
                            }
                        }
                        
                        throw openaiError; // Re-throw original error
                    }
                }

            } catch (error) {
                addLog(`Error in inference: ${error}`);
            } finally {
                document.getElementById('inference-btn').disabled = false;
                document.getElementById('inference-btn').textContent = 'Run AI Inference';
            }
        };

        const clearLogs = () => {
            document.getElementById('logs').innerHTML = '';
            document.getElementById('logs-container').classList.add('hidden');
            document.getElementById('response').classList.add('hidden');
        };

        document.getElementById('connect-btn').addEventListener('click', connectWallet);
        document.getElementById('inference-btn').addEventListener('click', runInference);
        document.getElementById('clear-btn').addEventListener('click', clearLogs);
    </script>
</body>
</html>
